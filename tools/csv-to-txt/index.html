<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<title>CSV to data_mappoints.txt</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body{font-family:system-ui,Arial,sans-serif;margin:24px}
  h1{font-size:1.25rem;margin:0 0 8px}
  .box{border:1px solid #ddd;padding:16px;border-radius:8px;max-width:800px}
  label{display:block;margin:12px 0 6px}
  input,button{font-size:1rem;padding:8px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .muted{font-size:.9rem;color:#666}
  .ok{color:green}.warn{color:#b45309}.err{color:#c00}
  table{border-collapse:collapse;margin-top:12px;font-size:.95rem}
  td,th{border:1px solid #eee;padding:6px 8px}
  .preview{max-height:200px;overflow:auto;border:1px dashed #ddd}
</style>

<body>
  <h1>CSV to <code>data_mappoints.txt</code></h1>
  <div class="box">
    <p>Upload a CSV with a header row. The tool will export a pipe-separated text file in this exact order:</p>
    <ol>
      <li>Hari/Tanggal (Date)</li>
      <li>Jam (Time)</li>
      <li>Jenis (Species)</li>
      <li>Jumlah Individu (Count)</li>
      <li>Distrik (District)</li>
      <li>Titik Koordinat (Coord)</li>
      <li>Tipe Habitat (Habitat)</li>
      <li>Lokasi (Location)</li>
      <li>Aktivitas (Activity)</li>
    </ol>

    <div class="row">
      <input type="file" id="csv" accept=".csv,text/csv">
      <button id="convert" disabled>Convert → TXT</button>
    </div>
    <p class="muted">Header synonyms (case-insensitive, ID/EN) are accepted, e.g. <em>Tanggal/Date</em>, <em>Jam/Time</em>, <em>Jenis/Species</em>, <em>Jumlah Individu/Count</em>, <em>Distrik/District</em>, <em>Koordinat/Coordinate</em>, etc.</p>
    <div id="status" class="muted"></div>
    <div class="preview" id="preview" hidden></div>
  </div>

  <!-- Papa Parse (robust CSV parser). You can self-host; see note below. -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
  (function(){
    const csvEl = document.getElementById('csv');
    const convertBtn = document.getElementById('convert');
    const statusEl = document.getElementById('status');
    const previewEl = document.getElementById('preview');

    // Output order
    const ORDER = ['date','time','species','count','district','coord','habitat','location','activity'];

    // Header synonyms (exactly as you requested)
    const SYN = {
      date:     ['tanggal','hari/tanggal','date','tgl','hari tanggal'],
      time:     ['jam','waktu','time','pukul'],
      species:  ['jenis','spesies','species','taxon','nama jenis','scientific name','common name'],
      count:    ['jumlah individu','jumlah','count','abundance','n','number'],
      district: ['distrik','kecamatan','district','desa/kelurahan','village'],
      coord:    ['titik koordinat','koordinat','coord','coordinate','coordinates','lat long','lat/long','latitude longitude','gps'],
      habitat:  ['tipe habitat','habitat','habitat type'],
      location: ['lokasi','site','micro-site','micro site','spot'],
      activity: ['aktivitas','activity','behavior','behaviour']
    };

    let PARSED = null;

    csvEl.addEventListener('change', async () => {
      resetUI();
      const f = csvEl.files[0];
      if(!f){ return; }
      status('Reading CSV …');

      Papa.parse(f, {
        header: true,
        skipEmptyLines: 'greedy',
        dynamicTyping: false,
        transformHeader: h => String(h||'').trim(),
        complete: (res) => {
          if(res.errors && res.errors.length){
            status('CSV parse warnings: ' + res.errors.slice(0,2).map(e=>e.message).join('; ') + (res.errors.length>2?' …':''), 'warn');
          } else {
            status('CSV loaded. Click Convert.', 'ok');
          }
          PARSED = res;
          convertBtn.disabled = false;
        },
        error: (err) => {
          status('Failed to parse CSV: '+err.message, 'err');
        }
      });
    });

    convertBtn.addEventListener('click', () => {
      if(!PARSED){return;}
      const headers = (PARSED.meta && PARSED.meta.fields) ? PARSED.meta.fields : [];
      if(!headers.length) return status('No header row found. Please include column names in the first row.', 'err');

      // Build header map
      const map = autoMap(headers);
      const missing = ORDER.filter(k => map[k] === -1);
      if(missing.length){
        return status('Missing columns: '+missing.join(', ')+'. Please adjust your header row.', 'err');
      }

      // Build output
      const outLines = [];
      const rows = PARSED.data || [];
      let kept = 0, skipped = 0;
      for(const row of rows){
        // ignore entirely empty rows
        if(Object.values(row).every(v => String(v).trim() === '')) continue;

        const vals = ORDER.map(k => cleanCell(row[ headers[ map[k] ] ], k));
        // require Species and Coord
        if(!vals[2] || !vals[5]) { skipped++; continue; }
        outLines.push(vals.join(' | '));
        kept++;
      }
      if(!outLines.length){
        return status('All rows are empty or invalid (need Species and Coord).', 'warn');
      }

      // Preview
      const firstN = Math.min(10, outLines.length);
      const sample = outLines.slice(0,firstN).map((l,i)=>`${i+1}. ${l}`).join('<br>');
      previewEl.innerHTML = `<table><tr><th>Preview (first ${firstN} of ${outLines.length} lines)</th></tr><tr><td style="white-space:pre">${sample}</td></tr></table>`;
      previewEl.hidden = false;

      // Download
      const blob = new Blob([outLines.join('\n')], {type:'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'data_mappoints.txt';
      a.click();

      status(`Done. Downloaded data_mappoints.txt (kept ${kept}, skipped ${skipped}).`, 'ok');
    });

    // ---------- helpers (mirrored with XLSX tool) ----------
    function autoMap(headers){
      const low = headers.map(h => normalizeHeader(h));
      const map = {};
      for(const key of ORDER){
        map[key] = findIndex(low, SYN[key]);
      }
      return map;
    }
    function findIndex(lowHeaders, synonyms){
      for(let i=0;i<lowHeaders.length;i++){
        const h = lowHeaders[i];
        if(!h) continue;
        for(const syn of synonyms){
          const s = normalizeHeader(syn);
          if(h === s || h.includes(s) || s.includes(h)) return i;
        }
      }
      return -1;
    }
    function normalizeHeader(s){
      return String(s).toLowerCase()
        .replace(/_/g,' ')
        .replace(/\s+/g,' ')
        .replace(/[^\w\s/.-]/g,'')   // keep slash/dot/dash
        .trim();
    }

    function cleanCell(v, key){
      if(v == null) return '';
      let s = String(v).trim();

      // try to normalize date/time strings
      if(key === 'date'){
        // Excel → CSV typically exports as text; handle common formats
        const d = parseLooseDate(s);
        if(d) return toYYYYMMDD(d);

        // numeric-looking dates (rare in CSV but handle anyway)
        if(/^\d{5}(\.\d+)?$/.test(s)){ // Excel serial (rough heuristic)
          return toYYYYMMDD(excelSerialToDate(Number(s)));
        }
      }
      if(key === 'time'){
        const t = parseLooseTime(s);
        if(t) return t;
        if(/^\d{5}(\.\d+)?$/.test(s)){ // Excel serial time
          return toHHMM(excelSerialToDate(Number(s)));
        }
      }

      // sanitize delimiters and newlines
      s = s.replace(/\r?\n/g,' ').replace(/\|/g,'/');

      return s;
    }

    function excelSerialToDate(serial){
      const utc_days = Math.floor(serial - 25569);
      const utc_value = utc_days * 86400;
      const date_info = new Date(utc_value * 1000);
      const fractional = serial - Math.floor(serial);
      const ms = Math.round(fractional * 24 * 60 * 60 * 1000);
      return new Date(date_info.getTime() + ms);
    }
    function toYYYYMMDD(d){
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
    function toHHMM(d){
      const h = String(d.getHours()).padStart(2,'0');
      const m = String(d.getMinutes()).padStart(2,'0');
      return `${h}:${m}`;
    }
    function parseLooseDate(s){
      // YYYY-MM-DD
      let m = s.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/);
      if(m) return new Date(Number(m[1]), Number(m[2])-1, Number(m[3]));
      // DD/MM/YYYY or DD-MM-YYYY (assume Indonesian order)
      m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
      if(m) return new Date(Number(m[3]), Number(m[2])-1, Number(m[1]));
      return null;
    }
    function parseLooseTime(s){
      // HH:MM or H:MM AM/PM
      const a = s.match(/^(\d{1,2}):(\d{2})(?:\s*([AaPp][Mm]))?$/);
      if(!a) return null;
      let hh = Number(a[1]), mm = Number(a[2]);
      const ap = a[3];
      if(ap){
        const pm = /^[Pp]/.test(ap);
        if(hh === 12){ hh = pm ? 12 : 0; }
        else if(pm){ hh += 12; }
      }
      if(hh<0||hh>23||mm<0||mm>59) return null;
      return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
    }

    function status(msg, kind){
      statusEl.textContent = msg;
      statusEl.className = kind ? kind : '';
    }
    function resetUI(){
      previewEl.hidden = true;
      status('');
      convertBtn.disabled = true;
    }
  })();
  </script>
</body>
</html>
